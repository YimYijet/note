<h1 class="mb-0 align-center">goroutine 调度原理</h1>

#### 并行和并发的区别

并发我们可以理解为一个人一会看看书，一会敲敲代码，实质上是一个屋里CPU或多个物理CPU在若干个程序之间多路复用，所有的并发处理都有排队等候、唤醒、执行至少这样三个步骤，它们都是序列被处理的，只不过资源不会再某一个上被阻塞（一般是通过时间片轮转），所以看上去多个同时到达的请求同时被处理。  

并行可以理解为一个人一边听歌一边敲代码，实质上是两个或者两个以上事件或活动在同一时刻发生。

#### Go的并发是怎么实现的呢

在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。goroutine可以多路复用，交叉编译。

多路复用，指的是多个任务在多个线程中，交叉执行。加入当一个G执行过程遇到阻塞了，此时就会放入到G队列，执行下一个G，也许这个阻塞G会被放入全局队列然后转入其他P下面的G队列继续执行。

#### 两级线程模型

Go 不推荐用共享内存的方式传递数据，而推荐用channel。channel主要用来在多个goroutine之间传递数据，并且还会保证整个过程的并发安全性。

说起Go 的线程实现模型，有三个核心元素，它们支撑起了这个模型的主框架。

1. M：machine的缩写。一个M代表一个内核线程，或称为“工作线程”。
2. P：processor的缩写。一个P代表执行一个Go代码片段所需的上下文环境。
3. G：goroutine的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。

![d](https://upload-images.jianshu.io/upload_images/1767848-fc23b15dc52e407f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/307)

简单来说，M和P一对一关联之后，就形成了一个有效的G运行环境（内核线程 + 上下文环境）。每个P都会包含一个可运行的G的队列。

整个的调度过程可以简单的理解为，调度器先去初始化M，然后检查P中的G队列，如果有，则执行，如果没有，回去全局队列中取一队G队列回来执行，如果全局队列也为空，此时就会从别的P下面的G队列中取回来一些放入到自己的G队列进行执行。

下面我们来分别说下M、P、G。

一个M代表一个内核线程。在大多数情况下，创建一个M，都是由于没有足够的M来关联P并运行其中可运行的G。

P是G能够在M中运行的关键。Go的运行时系统会适时的让P与不同的M建立或断开关联，以使P中的那些可运行的G能够及时获得运行时机，这与操作系统内核在CPU之上实时的切换不同的进程或线程的情形类似。

P的最大数量实际上是对程序中并发运行的G的规模的一种限制。P的数量即为可运行G的队列的数量。一个G在被启用后，会先被追加到某个P的可运行G队列中，以等待运行时机。

一个G就代表一个goroutine，也与go函数相对应。G对象本身是复用的。运行时系统在接到这样一个调用之后，会先检查go函数及其参数的合法性，然后试图从本地P的自由G列表和调度器的自由G列表获取可用的G，如果没有获取到，就新建一个G。与M和P相同，运行时系统也持有一个G的全局列表。新建的G会在第一时间被加入到该列表。

一个G在运行的过程中，是否会等待某个时间以及会等待什么样的事件，完全由其封装的go函数决定。例如，如果这个函数中包含对通道值得操作，那么在执行到对应代码的时候，这个G就有可能进入Gwaiting状态。这可能是在等待从通道类型值中接收值，也可能是在等待向通道类型值发送值。又例如，涉及网络I/O的时候也会导致相应的G进入Gwaiting状态，此外，操纵定时器（time.Timer）和调用time.Sleep函数同样会造成相应G的等待。

调度器对G队列长度是有限制的，当达到某个限制的时候，这个G队列接下来的G就会转移到全局队列，此时调度器就会唤醒M，唤醒M的过程有三种能，第一种可能是，当前有空闲M，直接唤醒M，第二可能是，当前没有空闲M，但是有个P是空闲的，我就创建一个M，与P关联。第三情况是，当前所有核心也就是P都被占用了，那么就唤醒失败，队列阻塞。






